URM_Status = relevel(as.factor(URM_Status), ref = 'Majority'),
First_Gen_Status = relevel(as.factor(First_Gen_Status), ref = 'ContGen'),
AP_Calculus_AB = relevel(as.factor(AP_Calculus_AB), ref = 'NotTaken'),
AP_Calculus_BC = relevel(as.factor(AP_Calculus_BC), ref = 'NotTaken'),
Semester = relevel(as.factor(Semester), ref = 'FA'),
Sequence = relevel(as.factor(Sequence), ref = 'Engineering'),
Course_Content = as.factor(Course_Content),
Class_ID = as.factor(Class_ID),
ACT_SAT_Math_Percentile = c(scale(ACT_SAT_Math_Percentile, scale = TRUE)),
PreScores = c(scale(PreScores, scale = TRUE)),
PostScores = c(scale(PostScores, scale = TRUE)))
if(impute){
levels(df.assessment$Class_ID) <- 1:length(levels(df.assessment$Class_ID))
df.assessment$Class_ID <- as.numeric(df.assessment$Class_ID)
Frac.Missing <- round(sum(is.na(df.assessment$PreScores) |
is.na(df.assessment$PostScores))/
nrow(df.assessment) * 100)
print('% of students without matched data:')
print(Frac.Missing)
ini <- mice(df.assessment, maxit = 0)
predM <- ini$predictorMatrix
iniM <- ini$method
print(iniM)
predM[, 'Class_ID'] <- -2 # Class_ID is the grouping variable
print(predM)
# 2l.pmmm of noth pretest and posttest scores
iniM <- c('', '', '', '', '', '', '', '2l.pmm', '2l.pmm', '', '', '', '', '')
print(iniM)
set.seed(11)
imp.dat <- mice(df.assessment, m = Frac.Missing, pred = predM, met = iniM,
print = FALSE)
return(imp.dat)
}
return(df.assessment)
}
Impute.Analayze <- function(assessment){
df.imp <- Load.Clean.Data(assessment = assessment, impute = TRUE)
if(assessment == 'ECLASS' | assessment == 'PLIC'){
model <- 'PostScores ~ Gender + URM_Status + Class_Standing + First_Gen_Status + PreScores + ACT_SAT_Math_Percentile + AP_Calculus_AB + AP_Calculus_BC + Semester + Sequence + Course_Content + (1 | Class_ID)'
} else {
model <- 'PostScores ~ Gender + URM_Status + Class_Standing + First_Gen_Status + PreScores + ACT_SAT_Math_Percentile + AP_Calculus_AB + AP_Calculus_BC + Semester + Sequence + (1 | Class_ID)'
}
fit <- with(df.imp, lme4::lmer(formula(model)))
print(summary(pool(fit)))
df.complete <- mice::complete(df.imp, "long", include = FALSE)
R2M.L <- c()
R2C.L <- c()
AIC.L <- c()
m <- max(df.complete$.imp)
for(i in 1:m){
model.imputed <- lme4::lmer(formula(model), data = df.complete[which(df.complete$.imp == i),])
R2 <- r.squaredGLMM(model.imputed)
R2M.L[i] <- R2[1, 'R2m']
R2C.L[i] <- R2[1, 'R2c']
AIC.L[i] <- AIC(model.imputed)
}
print(mean(R2M.L))
print(sd(R2M.L))
print(mean(R2C.L))
print(sd(R2C.L))
print(mean(AIC.L))
print(sd(AIC.L))
}
Impute.Analayze('MBT')
Load.Clean.Data <- function(File = 'OVB_Master.csv', assessment, impute = FALSE) {
# read in Master file, filter for particular assessment, and perform some data cleaning
# also impute data if desired
vars <- c('Class_Standing', 'Gender', 'URM_Status', 'First_Gen_Status',
'AP_Calculus_AB', 'AP_Calculus_BC', 'ACT_SAT_Math_Percentile', 'PreScores',
'PostScores', 'Semester', 'Sequence', 'Course_Content', 'Class_ID')
df <- fread(File)
if(impute){
df.assessment <- df[Assessment == assessment]
} else { # only get matched data if not imputing
vars <- c(vars, 'GPA')
df.assessment <- df[Assessment == assessment & (!is.na(PreScores) &
!is.na(PostScores))]
}
df.assessment <- df.assessment %>%
select(vars) %>%
mutate(Class_Standing = relevel(as.factor(case_when(
Class_Standing == 'Fresh' ~ 'FY',
Class_Standing == 'Sophomore' | Class_Standing == 'Junior' |
Class_Standing == 'Senior' ~ 'BFY',
TRUE ~ NA_character_
)), ref = 'FY'),
Gender = relevel(as.factor(Gender), ref = 'M'),
URM_Status = relevel(as.factor(URM_Status), ref = 'Majority'),
First_Gen_Status = relevel(as.factor(First_Gen_Status), ref = 'ContGen'),
AP_Calculus_AB = relevel(as.factor(AP_Calculus_AB), ref = 'NotTaken'),
AP_Calculus_BC = relevel(as.factor(AP_Calculus_BC), ref = 'NotTaken'),
Semester = relevel(as.factor(Semester), ref = 'FA'),
Sequence = relevel(as.factor(Sequence), ref = 'Engineering'),
Course_Content = as.factor(Course_Content),
Class_ID = as.factor(Class_ID),
ACT_SAT_Math_Percentile = c(scale(ACT_SAT_Math_Percentile, scale = TRUE)),
PreScores = c(scale(PreScores, scale = TRUE)),
PostScores = c(scale(PostScores, scale = TRUE)))
if(impute){
print(head(df.assessment))
levels(df.assessment$Class_ID) <- 1:length(levels(df.assessment$Class_ID))
df.assessment$Class_ID <- as.numeric(df.assessment$Class_ID)
Frac.Missing <- round(sum(is.na(df.assessment$PreScores) |
is.na(df.assessment$PostScores))/
nrow(df.assessment) * 100)
print('% of students without matched data:')
print(Frac.Missing)
ini <- mice(df.assessment, maxit = 0)
predM <- ini$predictorMatrix
iniM <- ini$method
predM[, 'Class_ID'] <- -2 # Class_ID is the grouping variable
# 2l.pmmm of noth pretest and posttest scores
iniM <- c('', '', '', '', '', '', '', '2l.pmm', '2l.pmm', '', '', '', '', '')
set.seed(11)
imp.dat <- mice(df.assessment, m = Frac.Missing, pred = predM, met = iniM,
print = FALSE)
return(imp.dat)
}
return(df.assessment)
}
Impute.Analayze <- function(assessment){
df.imp <- Load.Clean.Data(assessment = assessment, impute = TRUE)
if(assessment == 'ECLASS' | assessment == 'PLIC'){
model <- 'PostScores ~ Gender + URM_Status + Class_Standing + First_Gen_Status + PreScores + ACT_SAT_Math_Percentile + AP_Calculus_AB + AP_Calculus_BC + Semester + Sequence + Course_Content + (1 | Class_ID)'
} else {
model <- 'PostScores ~ Gender + URM_Status + Class_Standing + First_Gen_Status + PreScores + ACT_SAT_Math_Percentile + AP_Calculus_AB + AP_Calculus_BC + Semester + Sequence + (1 | Class_ID)'
}
fit <- with(df.imp, lme4::lmer(formula(model)))
print(summary(pool(fit)))
df.complete <- mice::complete(df.imp, "long", include = FALSE)
R2M.L <- c()
R2C.L <- c()
AIC.L <- c()
m <- max(df.complete$.imp)
for(i in 1:m){
model.imputed <- lme4::lmer(formula(model), data = df.complete[which(df.complete$.imp == i),])
R2 <- r.squaredGLMM(model.imputed)
R2M.L[i] <- R2[1, 'R2m']
R2C.L[i] <- R2[1, 'R2c']
AIC.L[i] <- AIC(model.imputed)
}
print(mean(R2M.L))
print(sd(R2M.L))
print(mean(R2C.L))
print(sd(R2C.L))
print(mean(AIC.L))
print(sd(AIC.L))
}
Impute.Analayze('MBT')
Load.Clean.Data <- function(File = 'OVB_Master.csv', assessment, impute = FALSE) {
# read in Master file, filter for particular assessment, and perform some data cleaning
# also impute data if desired
vars <- c('Class_Standing', 'Gender', 'URM_Status', 'First_Gen_Status',
'AP_Calculus_AB', 'AP_Calculus_BC', 'ACT_SAT_Math_Percentile', 'PreScores',
'PostScores', 'Semester', 'Sequence', 'Course_Content', 'Class_ID')
df <- fread(File)
if(impute){
df.assessment <- df[Assessment == assessment]
} else { # only get matched data if not imputing
vars <- append(vars, 'GPA')
df.assessment <- df[Assessment == assessment & (!is.na(PreScores) &
!is.na(PostScores))]
}
df.assessment <- df.assessment %>%
select(vars) %>%
mutate(Class_Standing = relevel(as.factor(case_when(
Class_Standing == 'Fresh' ~ 'FY',
Class_Standing == 'Sophomore' | Class_Standing == 'Junior' |
Class_Standing == 'Senior' ~ 'BFY',
TRUE ~ NA_character_
)), ref = 'FY'),
Gender = relevel(as.factor(Gender), ref = 'M'),
URM_Status = relevel(as.factor(URM_Status), ref = 'Majority'),
First_Gen_Status = relevel(as.factor(First_Gen_Status), ref = 'ContGen'),
AP_Calculus_AB = relevel(as.factor(AP_Calculus_AB), ref = 'NotTaken'),
AP_Calculus_BC = relevel(as.factor(AP_Calculus_BC), ref = 'NotTaken'),
Semester = relevel(as.factor(Semester), ref = 'FA'),
Sequence = relevel(as.factor(Sequence), ref = 'Engineering'),
Course_Content = as.factor(Course_Content),
Class_ID = as.factor(Class_ID),
ACT_SAT_Math_Percentile = c(scale(ACT_SAT_Math_Percentile, scale = TRUE)),
PreScores = c(scale(PreScores, scale = TRUE)),
PostScores = c(scale(PostScores, scale = TRUE)))
if(impute){
levels(df.assessment$Class_ID) <- 1:length(levels(df.assessment$Class_ID))
df.assessment$Class_ID <- as.numeric(df.assessment$Class_ID)
Frac.Missing <- round(sum(is.na(df.assessment$PreScores) |
is.na(df.assessment$PostScores))/
nrow(df.assessment) * 100)
print('% of students without matched data:')
print(Frac.Missing)
ini <- mice(df.assessment, maxit = 0)
predM <- ini$predictorMatrix
iniM <- ini$method
predM[, 'Class_ID'] <- -2 # Class_ID is the grouping variable
# 2l.pmmm of noth pretest and posttest scores
iniM <- c('', '', '', '', '', '', '', '2l.pmm', '2l.pmm', '', '', '', '', '')
set.seed(11)
imp.dat <- mice(df.assessment, m = Frac.Missing, pred = predM, met = iniM,
print = FALSE)
return(imp.dat)
}
return(df.assessment)
}
Impute.Analayze <- function(assessment){
df.imp <- Load.Clean.Data(assessment = assessment, impute = TRUE)
if(assessment == 'ECLASS' | assessment == 'PLIC'){
model <- 'PostScores ~ Gender + URM_Status + Class_Standing + First_Gen_Status + PreScores + ACT_SAT_Math_Percentile + AP_Calculus_AB + AP_Calculus_BC + Semester + Sequence + Course_Content + (1 | Class_ID)'
} else {
model <- 'PostScores ~ Gender + URM_Status + Class_Standing + First_Gen_Status + PreScores + ACT_SAT_Math_Percentile + AP_Calculus_AB + AP_Calculus_BC + Semester + Sequence + (1 | Class_ID)'
}
fit <- with(df.imp, lme4::lmer(formula(model)))
print(summary(pool(fit)))
df.complete <- mice::complete(df.imp, "long", include = FALSE)
R2M.L <- c()
R2C.L <- c()
AIC.L <- c()
m <- max(df.complete$.imp)
for(i in 1:m){
model.imputed <- lme4::lmer(formula(model), data = df.complete[which(df.complete$.imp == i),])
R2 <- r.squaredGLMM(model.imputed)
R2M.L[i] <- R2[1, 'R2m']
R2C.L[i] <- R2[1, 'R2c']
AIC.L[i] <- AIC(model.imputed)
}
print(mean(R2M.L))
print(sd(R2M.L))
print(mean(R2C.L))
print(sd(R2C.L))
print(mean(AIC.L))
print(sd(AIC.L))
}
Impute.Analayze('MBT')
Load.Clean.Data <- function(File = 'OVB_Master.csv', assessment, impute = FALSE) {
# read in Master file, filter for particular assessment, and perform some data cleaning
# also impute data if desired
vars <- c('Class_Standing', 'Gender', 'URM_Status', 'First_Gen_Status',
'AP_Calculus_AB', 'AP_Calculus_BC', 'ACT_SAT_Math_Percentile', 'PreScores',
'PostScores', 'Semester', 'Sequence', 'Course_Content', 'Class_ID')
df <- fread(File)
if(impute){
df.assessment <- df[Assessment == assessment]
} else { # only get matched data if not imputing
vars <- append(vars, 'GPA')
df.assessment <- df[Assessment == assessment & (!is.na(PreScores) &
!is.na(PostScores))]
}
df.assessment <- df.assessment %>%
select(vars) %>%
mutate(Class_Standing = relevel(as.factor(case_when(
Class_Standing == 'Fresh' ~ 'FY',
Class_Standing == 'Sophomore' | Class_Standing == 'Junior' |
Class_Standing == 'Senior' ~ 'BFY',
TRUE ~ NA_character_
)), ref = 'FY'),
Gender = relevel(as.factor(Gender), ref = 'M'),
URM_Status = relevel(as.factor(URM_Status), ref = 'Majority'),
First_Gen_Status = relevel(as.factor(First_Gen_Status), ref = 'ContGen'),
AP_Calculus_AB = relevel(as.factor(AP_Calculus_AB), ref = 'NotTaken'),
AP_Calculus_BC = relevel(as.factor(AP_Calculus_BC), ref = 'NotTaken'),
Semester = relevel(as.factor(Semester), ref = 'FA'),
Sequence = relevel(as.factor(Sequence), ref = 'Engineering'),
Course_Content = as.factor(Course_Content),
Class_ID = as.factor(Class_ID),
ACT_SAT_Math_Percentile = c(scale(ACT_SAT_Math_Percentile, scale = TRUE)),
PreScores = c(scale(PreScores, scale = TRUE)),
PostScores = c(scale(PostScores, scale = TRUE)))
if(impute){
print(head(df.assessment))
levels(df.assessment$Class_ID) <- 1:length(levels(df.assessment$Class_ID))
df.assessment$Class_ID <- as.numeric(df.assessment$Class_ID)
Frac.Missing <- round(sum(is.na(df.assessment$PreScores) |
is.na(df.assessment$PostScores))/
nrow(df.assessment) * 100)
print('% of students without matched data:')
print(Frac.Missing)
ini <- mice(df.assessment, maxit = 0)
predM <- ini$predictorMatrix
iniM <- ini$method
predM[, 'Class_ID'] <- -2 # Class_ID is the grouping variable
# 2l.pmmm of noth pretest and posttest scores
iniM <- c('', '', '', '', '', '', '', '2l.pmm', '2l.pmm', '', '', '', '', '')
set.seed(11)
imp.dat <- mice(df.assessment, m = Frac.Missing, pred = predM, met = iniM,
print = FALSE)
return(imp.dat)
}
return(df.assessment)
}
Impute.Analayze <- function(assessment){
df.imp <- Load.Clean.Data(assessment = assessment, impute = TRUE)
if(assessment == 'ECLASS' | assessment == 'PLIC'){
model <- 'PostScores ~ Gender + URM_Status + Class_Standing + First_Gen_Status + PreScores + ACT_SAT_Math_Percentile + AP_Calculus_AB + AP_Calculus_BC + Semester + Sequence + Course_Content + (1 | Class_ID)'
} else {
model <- 'PostScores ~ Gender + URM_Status + Class_Standing + First_Gen_Status + PreScores + ACT_SAT_Math_Percentile + AP_Calculus_AB + AP_Calculus_BC + Semester + Sequence + (1 | Class_ID)'
}
fit <- with(df.imp, lme4::lmer(formula(model)))
print(summary(pool(fit)))
df.complete <- mice::complete(df.imp, "long", include = FALSE)
R2M.L <- c()
R2C.L <- c()
AIC.L <- c()
m <- max(df.complete$.imp)
for(i in 1:m){
model.imputed <- lme4::lmer(formula(model), data = df.complete[which(df.complete$.imp == i),])
R2 <- r.squaredGLMM(model.imputed)
R2M.L[i] <- R2[1, 'R2m']
R2C.L[i] <- R2[1, 'R2c']
AIC.L[i] <- AIC(model.imputed)
}
print(mean(R2M.L))
print(sd(R2M.L))
print(mean(R2C.L))
print(sd(R2C.L))
print(mean(AIC.L))
print(sd(AIC.L))
}
Impute.Analayze('MBT')
Load.Clean.Data <- function(File = 'OVB_Master.csv', assessment, impute = FALSE) {
# read in Master file, filter for particular assessment, and perform some data cleaning
# also impute data if desired
vars <- c('Class_Standing', 'Gender', 'URM_Status', 'First_Gen_Status',
'AP_Calculus_AB', 'AP_Calculus_BC', 'ACT_SAT_Math_Percentile', 'PreScores',
'PostScores', 'Semester', 'Sequence', 'Course_Content', 'Class_ID')
df <- fread(File)
if(impute){
df.assessment <- df[Assessment == assessment]
} else { # only get matched data if not imputing
vars <- append(vars, 'GPA')
df.assessment <- df[Assessment == assessment & (!is.na(PreScores) &
!is.na(PostScores))]
}
df.assessment <- df.assessment %>%
select(vars) %>%
mutate(Class_Standing = relevel(as.factor(case_when(
Class_Standing == 'Fresh' ~ 'FY',
Class_Standing == 'Sophomore' | Class_Standing == 'Junior' |
Class_Standing == 'Senior' ~ 'BFY',
TRUE ~ NA_character_
)), ref = 'FY'),
Gender = relevel(as.factor(Gender), ref = 'M'),
URM_Status = relevel(as.factor(URM_Status), ref = 'Majority'),
First_Gen_Status = relevel(as.factor(First_Gen_Status), ref = 'ContGen'),
AP_Calculus_AB = relevel(as.factor(AP_Calculus_AB), ref = 'NotTaken'),
AP_Calculus_BC = relevel(as.factor(AP_Calculus_BC), ref = 'NotTaken'),
Semester = relevel(as.factor(Semester), ref = 'FA'),
Sequence = relevel(as.factor(Sequence), ref = 'Engineering'),
Course_Content = as.factor(Course_Content),
Class_ID = as.factor(Class_ID),
ACT_SAT_Math_Percentile = c(scale(ACT_SAT_Math_Percentile, scale = TRUE)),
PreScores = c(scale(PreScores, scale = TRUE)),
PostScores = c(scale(PostScores, scale = TRUE)))
if(impute){
print(vars)
print(head(df.assessment))
levels(df.assessment$Class_ID) <- 1:length(levels(df.assessment$Class_ID))
df.assessment$Class_ID <- as.numeric(df.assessment$Class_ID)
Frac.Missing <- round(sum(is.na(df.assessment$PreScores) |
is.na(df.assessment$PostScores))/
nrow(df.assessment) * 100)
print('% of students without matched data:')
print(Frac.Missing)
ini <- mice(df.assessment, maxit = 0)
predM <- ini$predictorMatrix
iniM <- ini$method
predM[, 'Class_ID'] <- -2 # Class_ID is the grouping variable
# 2l.pmmm of noth pretest and posttest scores
iniM <- c('', '', '', '', '', '', '', '2l.pmm', '2l.pmm', '', '', '', '', '')
set.seed(11)
imp.dat <- mice(df.assessment, m = Frac.Missing, pred = predM, met = iniM,
print = FALSE)
return(imp.dat)
}
return(df.assessment)
}
Load.Clean.Data <- function(File = 'OVB_Master.csv', assessment, impute = FALSE) {
# read in Master file, filter for particular assessment, and perform some data cleaning
# also impute data if desired
vars <- c('Class_Standing', 'Gender', 'URM_Status', 'First_Gen_Status',
'AP_Calculus_AB', 'AP_Calculus_BC', 'ACT_SAT_Math_Percentile', 'PreScores',
'PostScores', 'Semester', 'Sequence', 'Course_Content', 'Class_ID')
df <- fread(File)
if(impute){
vars <- append(vars, 'GPA')
df.assessment <- df[Assessment == assessment]
} else { # only get matched data if not imputing
df.assessment <- df[Assessment == assessment & (!is.na(PreScores) &
!is.na(PostScores))]
}
df.assessment <- df.assessment %>%
select(vars) %>%
mutate(Class_Standing = relevel(as.factor(case_when(
Class_Standing == 'Fresh' ~ 'FY',
Class_Standing == 'Sophomore' | Class_Standing == 'Junior' |
Class_Standing == 'Senior' ~ 'BFY',
TRUE ~ NA_character_
)), ref = 'FY'),
Gender = relevel(as.factor(Gender), ref = 'M'),
URM_Status = relevel(as.factor(URM_Status), ref = 'Majority'),
First_Gen_Status = relevel(as.factor(First_Gen_Status), ref = 'ContGen'),
AP_Calculus_AB = relevel(as.factor(AP_Calculus_AB), ref = 'NotTaken'),
AP_Calculus_BC = relevel(as.factor(AP_Calculus_BC), ref = 'NotTaken'),
Semester = relevel(as.factor(Semester), ref = 'FA'),
Sequence = relevel(as.factor(Sequence), ref = 'Engineering'),
Course_Content = as.factor(Course_Content),
Class_ID = as.factor(Class_ID),
ACT_SAT_Math_Percentile = c(scale(ACT_SAT_Math_Percentile, scale = TRUE)),
PreScores = c(scale(PreScores, scale = TRUE)),
PostScores = c(scale(PostScores, scale = TRUE)))
if(impute){
levels(df.assessment$Class_ID) <- 1:length(levels(df.assessment$Class_ID))
df.assessment$Class_ID <- as.numeric(df.assessment$Class_ID)
Frac.Missing <- round(sum(is.na(df.assessment$PreScores) |
is.na(df.assessment$PostScores))/
nrow(df.assessment) * 100)
print('% of students without matched data:')
print(Frac.Missing)
ini <- mice(df.assessment, maxit = 0)
predM <- ini$predictorMatrix
iniM <- ini$method
predM[, 'Class_ID'] <- -2 # Class_ID is the grouping variable
# 2l.pmmm of noth pretest and posttest scores
iniM <- c('', '', '', '', '', '', '', '2l.pmm', '2l.pmm', '', '', '', '', '')
set.seed(11)
imp.dat <- mice(df.assessment, m = Frac.Missing, pred = predM, met = iniM,
print = FALSE)
return(imp.dat)
}
return(df.assessment)
}
Impute.Analayze <- function(assessment){
df.imp <- Load.Clean.Data(assessment = assessment, impute = TRUE)
if(assessment == 'ECLASS' | assessment == 'PLIC'){
model <- 'PostScores ~ Gender + URM_Status + Class_Standing + First_Gen_Status + PreScores + ACT_SAT_Math_Percentile + AP_Calculus_AB + AP_Calculus_BC + Semester + Sequence + Course_Content + (1 | Class_ID)'
} else {
model <- 'PostScores ~ Gender + URM_Status + Class_Standing + First_Gen_Status + PreScores + ACT_SAT_Math_Percentile + AP_Calculus_AB + AP_Calculus_BC + Semester + Sequence + (1 | Class_ID)'
}
fit <- with(df.imp, lme4::lmer(formula(model)))
print(summary(pool(fit)))
df.complete <- mice::complete(df.imp, "long", include = FALSE)
R2M.L <- c()
R2C.L <- c()
AIC.L <- c()
m <- max(df.complete$.imp)
for(i in 1:m){
model.imputed <- lme4::lmer(formula(model), data = df.complete[which(df.complete$.imp == i),])
R2 <- r.squaredGLMM(model.imputed)
R2M.L[i] <- R2[1, 'R2m']
R2C.L[i] <- R2[1, 'R2c']
AIC.L[i] <- AIC(model.imputed)
}
print(mean(R2M.L))
print(sd(R2M.L))
print(mean(R2C.L))
print(sd(R2C.L))
print(mean(AIC.L))
print(sd(AIC.L))
}
Impute.Analayze('MBT')
Impute.Analayze('CSEM')
Impute.Analayze('ECLASS')
Impute.Analayze('PLIC')
# used the MBT since that dataset had the fewest number of level-2 samples
df.MBT.fit5.lm <- lm(PostScores ~ Gender + URM_Status + Class_Standing +
First_Gen_Status + PreScores + ACT_SAT_Math_Percentile +
AP_Calculus_AB + AP_Calculus_BC + Semester + Sequence + Class_ID,
data = df.MBT)
summary(df.MBT.fit5.lm)
AIC(df.MBT.fit5.lm)
stargazer(df.MBT.fit5$model, df.MBT.fit5.lm, star.cutoffs = c(0.05, 0.01, 0.001),
intercept.bottom = FALSE, out = paste('MBT_LMcomp.tex'), intercept.top = TRUE,
omit.stat = 'all')
# used the MBT since that dataset had the fewest number of level-2 samples
df.MBT.fit5.lm <- lm(PostScores ~ Gender + URM_Status + Class_Standing +
First_Gen_Status + PreScores + ACT_SAT_Math_Percentile +
AP_Calculus_AB + AP_Calculus_BC + Semester + Sequence + Class_ID,
data = df.MBT)
summary(df.MBT.fit5.lm)
AIC(df.MBT.fit5.lm)
stargazer(df.MBT.fit5$model, df.MBT.fit5.lm, star.cutoffs = c(0.05, 0.01, 0.001),
intercept.bottom = FALSE, out = paste('MBT_LMcomp.tex'), intercept.top = TRUE,
omit.stat = 'all')
library(pwr)
library(WebPower)
library(tidyverse)
library(reshape2)
power.vec <- seq(0.13, 0.99, 0.01)
wp.regression(p1 = 13, p2 = 9, f2 = 0.02, alpha = 0.05, power = 0.8)
Power.func <- function(effect, power){
# compute sample size required for power to measure a given effect at $\alpha = 0.05$
# significance
out <- wp.regression(p1 = 13, p2 = 9, f2 = effect, alpha = 0.05, power = power)
return(out$n)
}
df <- data.frame(Power = power.vec, N1 = sapply(power.vec, Power.func, effect = 0.02)) %>%
melt(., id.vars = 'Power')
ggplot(df, aes(x = value, y = Power)) +
theme_classic() +
geom_line(size = 1) +
labs(x = 'Sample size') +
geom_vline(xintercept = df[(df$Power == 0.8) & (df$variable == 'N1'), 'value'], linetype = 3, color = 'black', size = 1)
p.out.t <- pwr.t.test(d = 0.2, sig.level = 0.05, power = 0.95)
p.out.t
plot(p.out.t)
power.vec <- seq(0.1, 0.95, 0.05)
data.frame(Power = power.vec, N = sapply(power.vec, function (x) pwr.t.test(d = 0.2, sig.level = 0.05, power = x)$n)) %>%
ggplot(., aes(x = Power, y = N)) +
geom_point() +
theme_classic() +
geom_line(color = 'red') +
labs(y = 'Sample size required') +
geom_vline(xintercept = 0.8, linetype = 3, color = 'blue')
